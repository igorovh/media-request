import TwitchProvider from "next-auth/providers/twitch"
import { prisma } from "./prisma"
import { encrypt } from "./encryption"

export const authOptions = {
  // Trust the host - required for production deployments behind proxies
  trustHost: true,
  providers: [
    TwitchProvider({
      clientId: process.env.TWITCH_CLIENT_ID!,
      clientSecret: process.env.TWITCH_CLIENT_SECRET!,
      authorization: {
        params: {
          scope: "openid user:read:email chat:read",
        },
      },
    }),
  ],
  callbacks: {
    async signIn({ user, account, profile }: any) {
      if (!account || !profile) return false

      try {
        const twitchId = profile.sub || account.providerAccountId
        const username = profile.preferred_username || profile.login || user.name || ""

        // Encrypt tokens before storing
        const encryptedAccessToken = encrypt(account.access_token || "")
        const encryptedRefreshToken = encrypt(account.refresh_token || "")

        // Upsert user
        const dbUser = await prisma.user.upsert({
          where: { twitchId },
          update: {
            username,
            accessToken: encryptedAccessToken,
            refreshToken: encryptedRefreshToken,
            // Ensure playerToken exists, generate if missing
            playerToken: undefined, // Don't update if exists
          },
          create: {
            twitchId,
            username,
            accessToken: encryptedAccessToken,
            refreshToken: encryptedRefreshToken,
            // playerToken will be auto-generated by Prisma default
          },
        })

        // If playerToken is missing (shouldn't happen with default, but safety check)
        if (!dbUser.playerToken) {
          const { randomBytes } = await import("crypto")
          const timestamp = Date.now().toString(36)
          const random = randomBytes(16).toString("hex")
          const newToken = `cl${timestamp}${random}`
          await prisma.user.update({
            where: { id: dbUser.id },
            data: { playerToken: newToken },
          })
        }

        return true
      } catch (error) {
        console.error("Sign in error:", error)
        return false
      }
    },
    async session({ session, token }: any) {
      if (session.user && token.sub) {
        const user = await prisma.user.findUnique({
          where: { twitchId: token.sub },
        })

        if (user) {
          session.user.id = user.id
          session.user.twitchId = user.twitchId
          session.user.username = user.username
          session.user.playerToken = user.playerToken || ""
        }
      }
      return session
    },
    async jwt({ token, account, profile }: any) {
      if (account && profile) {
        token.sub = profile.sub || account.providerAccountId
      }
      return token
    },
  },
  pages: {
    signIn: "/",
  },
}

declare module "next-auth" {
  interface Session {
    user: {
      id: string
      twitchId: string
      username: string
      playerToken: string
      name?: string | null
      email?: string | null
      image?: string | null
    }
  }
}

